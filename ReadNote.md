# C# 图解教程
- [C# 图解教程](#c-%e5%9b%be%e8%a7%a3%e6%95%99%e7%a8%8b)
  - [Chapter 6: 深入理解类](#chapter-6-%e6%b7%b1%e5%85%a5%e7%90%86%e8%a7%a3%e7%b1%bb)
    - [静态类成员和常量成员](#%e9%9d%99%e6%80%81%e7%b1%bb%e6%88%90%e5%91%98%e5%92%8c%e5%b8%b8%e9%87%8f%e6%88%90%e5%91%98)
    - [属性](#%e5%b1%9e%e6%80%a7)
    - [构造函数](#%e6%9e%84%e9%80%a0%e5%87%bd%e6%95%b0)
    - [析构函数](#%e6%9e%90%e6%9e%84%e5%87%bd%e6%95%b0)
    - [`readonly`修饰符](#readonly%e4%bf%ae%e9%a5%b0%e7%ac%a6)
    - [`this`关键字](#this%e5%85%b3%e9%94%ae%e5%ad%97)
    - [索引器](#%e7%b4%a2%e5%bc%95%e5%99%a8)
      - [访问器的访问修饰符限制](#%e8%ae%bf%e9%97%ae%e5%99%a8%e7%9a%84%e8%ae%bf%e9%97%ae%e4%bf%ae%e9%a5%b0%e7%ac%a6%e9%99%90%e5%88%b6)
    - [分部类和分部方法](#%e5%88%86%e9%83%a8%e7%b1%bb%e5%92%8c%e5%88%86%e9%83%a8%e6%96%b9%e6%b3%95)
  - [Chapter 7: 类和继承](#chapter-7-%e7%b1%bb%e5%92%8c%e7%bb%a7%e6%89%bf)
    - [类继承](#%e7%b1%bb%e7%bb%a7%e6%89%bf)
    - [屏蔽基类成员](#%e5%b1%8f%e8%94%bd%e5%9f%ba%e7%b1%bb%e6%88%90%e5%91%98)
      - [基类访问： 关键字`base`](#%e5%9f%ba%e7%b1%bb%e8%ae%bf%e9%97%ae-%e5%85%b3%e9%94%ae%e5%ad%97base)
    - [使用基类的引用](#%e4%bd%bf%e7%94%a8%e5%9f%ba%e7%b1%bb%e7%9a%84%e5%bc%95%e7%94%a8)
      - [虚方法和覆写方法： `virtual` & `override`](#%e8%99%9a%e6%96%b9%e6%b3%95%e5%92%8c%e8%a6%86%e5%86%99%e6%96%b9%e6%b3%95-virtual--override)
      - [覆写标记为`override`的方法](#%e8%a6%86%e5%86%99%e6%a0%87%e8%ae%b0%e4%b8%baoverride%e7%9a%84%e6%96%b9%e6%b3%95)
    - [构造函数的执行](#%e6%9e%84%e9%80%a0%e5%87%bd%e6%95%b0%e7%9a%84%e6%89%a7%e8%a1%8c)
    - [成员访问修饰符](#%e6%88%90%e5%91%98%e8%ae%bf%e9%97%ae%e4%bf%ae%e9%a5%b0%e7%ac%a6)
      - [程序集间的继承](#%e7%a8%8b%e5%ba%8f%e9%9b%86%e9%97%b4%e7%9a%84%e7%bb%a7%e6%89%bf)
    - [抽象成员和抽象类](#%e6%8a%bd%e8%b1%a1%e6%88%90%e5%91%98%e5%92%8c%e6%8a%bd%e8%b1%a1%e7%b1%bb)
      - [密封类](#%e5%af%86%e5%b0%81%e7%b1%bb)
    - [静态类](#%e9%9d%99%e6%80%81%e7%b1%bb)
    - [扩展方法](#%e6%89%a9%e5%b1%95%e6%96%b9%e6%b3%95)
    - [命名约定](#%e5%91%bd%e5%90%8d%e7%ba%a6%e5%ae%9a)

## Chapter 6: 深入理解类

类成员声明语句：[特性] [修饰符：`private`/`public`/...] 核心声明

### 静态类成员和常量成员

类成员可以关联到：
- 一个实例：实例类成员，每个实例有自己的类成员副本，互不影响
- 类的整体：`static` => 静态类成员，和类名绑定 (ex: `Math.PI`)。 （表6-2 p89）

成员常量：`const` 
- 常量必须声明在类型内
- 与静态量不同，没有自己的存储位置
    - 在编译时被编译器替代。类似c和c++中的`#define`值。
    - 不能声明为`static`

### 属性

- 语法和字段类似，但为函数成员，不分配内存，而执行代码
- 带访问器 (`set`、`get`) 的方法，但不能显示调用（`.get()` => error!）
    - `set`访问器：带有一个隐式值参`value`
- 属性与公共字段在编译后的语义不同，改变属性的实现不用再重新编译访问它的其他程序集（p97）
- 自动实现属性 auto-implemented poperty
    - 编译器自动创建隐藏的后备字段，并自动挂载到get和set访问器上
    - 不能提供访问器的方法体，必须简单声明为分号，即：`set; get;` 
    - 必须同时提供读写访问器，只读或只写属性没有意义，其他方法不能访问该隐藏后备字段

```csharp
class Test
{
    public int MyValue
    {
        set; get;
    }
}
```

### 构造函数

- 实例构造函数：初始化每个新实例
    - 名称和类名相同，无返回值，可被重载(`this`访问器)
    - 隐式的默认构造函数只在无自定义的显式构造函数时才会被编译器创建。
- 静态构造函数： 初始化类级别的项，如类的静态字段
    - 只能有一个，且不能有访问修饰符
    - p104的问题？？？

### 析构函数 

p105 ？？？

### `readonly`修饰符

- 可在任意位置设置它的值，对比`const`字段只能在字段声明语句中初始化
- 可在运行时决定值，对比`const`字段值必须在编译时决定 => 什么意思？？？
- 有自己的存储位置，既可以是实例字段，也可以是静态字段，对比`const`的行为总是静态的

### `this`关键字

对当前实例的引用 => say no to 静态成员

出现的地方
- 实例构造函数
- 实例方法
- 属性和索引器的实例访问器

### 索引器

实现像数组一样访问多个字段
- 一组`get`和`set`访问器 => 和属性的类似性
- 和属性的不同：声明中有一组参数列表，使用`this`引用而不是名称
- 索引器重载：只要参数列表不同即可

```csharp
ReturnType this [Type param1, ...]
{
    get
    {
        ...
    }
    set
    {
        ...
    }
}
```

#### 访问器的访问修饰符限制

- 同时有`get`和`set`访问器时才能加访问修饰符
- 访问器必须同时出现，但却只能给一个加访问修饰符
- 加的访问修饰符的访问级别要比成员的级别更严格（p115 访问修饰符级别）

### 分部类和分部方法

p116 ？？？


## Chapter 7: 类和继承

### 类继承

```csharp
class OtherClass : SomeClass
{
    ...
}
```

所有类都派生自`object`类。
没有基类规格说明的类隐式地直接派生自类`object`

一个类声明的基类规格说明中只能有一个单独的类。
不过继承的层次是没有限制的。

### 屏蔽基类成员

派生类不能删除继承的任何成员，但可以名称相同的成员来屏蔽基类成员。
- 数据成员：相同类型，相同名称
- 函数成员：相同签名（名称和参数列表，不包括返回类型）
- 为了让编译器知道你在故意屏蔽，可以加上`new`修饰符
- 也可以屏蔽静态成员

#### 基类访问： 关键字`base`

用于访问被隐藏的继承成员。

使用过多，很可能说明程序需要更好的设计。

### 使用基类的引用

派生类的引用指向整个类对象，包括基类部分。

如果有一个派生类对象的引用，就可以获取该对象基类部分的引用，并用类型转换运算符转换成基类类型。
=> 这样基类部分的引用看到的是自身部分的实现 #[上一个问题]

#### 虚方法和覆写方法： `virtual` & `override`

使用基类引用调用派生类的方法 => 解决#[上一个问题]
- 基类方法用`virtual`标注
- 派生类方法用`override`标注

注意：
- 不能覆写`static`方法或非虚方法
- 覆写和被覆写的方法必须有相同的可访问性

#### 覆写标记为`override`的方法

对对象基类部分的引用调用覆写的方法，其要追溯到最高的派生级别
=> 理解：从`virtual`开始找到距离它最远的`override`方法
Examples：p128-p129

### 构造函数的执行

默认情况下，将调用基类的无参数构造函数。
若要指定，则可以使用`base`关键字。
对于当前类的指定，可以使用`this`关键字。

如果有多个构造函数，公共代码可以提取出来作为一个构造函数，供其他构造函数使用（借助`this`）。p133


### 成员访问修饰符

表7-1 p140
- `public`
- `private`: 只能同一个类里的代码
- `protected`：同一类或者派生类
- `internal`：同一程序集
- `protected internal`：同一程序集或者派生类

#### 程序集间的继承

`internal`类访问修饰符：同程序集内(namespace?)的类才能看到

跨程序集：
- 基类必须为`public`
- 在vs中的References节点添加对包含基类程序集的引用
- 在代码中为了更方便引用，可在源文件顶部放置`using`指令

### 抽象成员和抽象类

抽象成员是指设计为被覆写的函数成员，只能在抽象类中声明
- 必须为函数成员：方法、属性、事件、索引
- `abstract`修饰符标记
- 不能有实现代码。用**分号**替换实现。
- 在派生类中必须用相应成员覆写，指定`override`修饰符

表7-3 比较虚成员和抽象成员 p141

抽象类只能被用作其他类的基类，使用`abstract`声明。
- 不能实例化
- 可包含抽象成员或普通非抽象成员
- 可派生自另外的抽象类
- 派生自抽象类的派生类必须用`override`关键字实现该抽象类所有抽象成员，除非这个派生类自己也是抽象类

#### 密封类

和抽象类相反，只能被用作独立的类，不能被用作基类。

用`sealed`修饰符标注。

### 静态类

静态类中所有成员都是静态的，用于存放不受实例数据影响的数据和函数。
常见用途如创建包含数学方法和值的数据库。

- 本身用`static`标记
- 所有成员都是静态的
- 隐式密封，不能被继承

### 扩展方法

允许编写的方法和声明它的类之外的类关联，在类的实例上调用该方法。
=> 为一个写好/不能修改源代码的类添加新的方法 `Class.NewMethod()`

- 声明扩展方法的类必须声明为`static`
- 扩展方法本身必须声明为`static`
- 扩展方法必须包含关键字`this`作为它的第一个参数类型，并在后面跟着它所扩展的类的名称

```csharp
static class ExtendMyData
{
    public static double Average(this MyData md)
    {
        ...
    }
}
```

### 命名约定

名称要用全拼并有意义。
方法一般是动词或动宾。
类、变量、参数一般是名词。

- Pascal大小写，如 ProductType
  - 命名空间
  - 类型名称
  - 方法
  - 属性
  - 公共字段
- Camel大小写，如 poductType
  - 局部变量名称
  - 方法声明的形参名称
  - 私有和受保护的字段